# QUEEN tutorial for training of GPT-4

## Introduction of QUEEN

QUEEN (a framework to generate quinable and efficiently editable nucleotide sequence resources) is a Python programming module designed to describe, share credit DNA building processes and resources. DNA parts information can be imported from external annotated DNA files (GenBank and FASTA format). Output file (GenBank format) encodes the complete information of the constructed DNA and its annotations and enables the production of a quine code that self-reproduces the output file itself. In QUEEN, all of the manipulations required in DNA construction are covered by five simple operational functions, "cutdna", "cropdna", "modifyends", "flipdna", and "joindna" that can collectively represent any of the standard molecular DNA cloning processes, two search functions, "searchsequence" and "searchfeature", and two super functions, "editsequence" and "editfeature".  A new DNA can be designed by programming a Python script or using Jupyter Notebook, an interactive Python programming interpreter. The designed DNA product can be output in the GenBank file format that involves the history of its building process. The "quinable" feature of a QUEEN-generated GenBank file certifies that the annotated DNA material information and its production process are fully transparent, reproducible, inheritable, and modifiable by the community.



## Installation of QUEEN 

Please install QUEEN using the following command.

`pip install git+https://github.com/yachielab/QUEEN.git`



## How to use QUEEN

### 1. Creation of a QUEEN class object

QUEEN class defines a double-stranded (ds)DNA or single-stranded (ss)DNA object with sequence annotations (DNAfeature class objects). 

#### Example code 1.1: Create a QUEEN class object (blunt-ends) 

A `QUEEN_object` (blunt-end) is created by providing its top-stranded sequence (5’-to-3’). By default, the DNA topology will be linear.  

```python3 
from QUEEN.queen import *
dna = QUEEN(seq="CCGGTATGCGTCGA") 
```



#### Example code 1.2: Create a QUEEN class object (sticky-end)

The left and right values separated by `"/"` show the top and bottom strand sequences of the generating `QUEEN_object`, respectively. The top strand sequence is provided in the 5’-to-3’ direction from left to right, whereas the bottom strand sequence is provided in the 3′-to-5′ direction from left to right. Single-stranded regions can be provided by `"-"` for the corresponding nucleotide positions on the opposite strands. A:T and G:C base-pairing rule is required between the two strings except for the single-stranded positions.

**Source code**

```python
from QUEEN.queen import *
dna = QUEEN(seq="CCGGTATGCG----/----ATACGCAGCT") 
```



#### Example code 1.3: Create a circular QUEEN class object

The sequence topology of generating `QUEEN_object` can be specified by `"linear"` or` "circular"`.  

**Source code**

```python
from QUEEN.queen import *
dna = QUEEN(seq="CCGGTATGCGTCGA", topology="circular") 
```



#### Example code 1.4: Create a ssDNA QUEEN class object 

The single strand `QUEEN_object` can be generated by specifying `ssdna=True`.    

**Source code**

```python
from QUEEN.queen import *
dna = QUEEN(seq="CCGGTATGCGTCGA", ssdna=True) 
```



#### Example code 1.5: Create a QUEEN class object from a GenBank file in a local directory

GenBank file can be loaded by specifying its local file path.  

**Source code**

```python
from QUEEN.queen import *
pUC19 = QUEEN(record="./input/pUC19.gbk")
```



#### Example code 1.6: Create a QUEEN class object using a NCBI accession number

QUEEN_object can be generated from a NCBI accession number with `dbtype="ncbi"`.  

**Source code**

```python
from QUEEN.queen import *
#"M77789.2" is NCBI accession number for pUC19 plasmid
pUC19 = QUEEN(record="M77789.2", dbtype="ncbi") 
```



#### Example code 1.7: Create a QUEEN class object using an Addgene plasmid ID

`QUEEN_object` can be generated from an Addgene plasmid ID with `dbtype="addgene"`.  

**Source code**

```python
from QUEEN.queen import *
#"50005" is Addgene plasmid ID for pUC19 plasmid
pUC19 = QUEEN(record="50005", dbtype="addgene")
```



#### Example code 1.8: Create a QUEEN class object from a Benchling share link

`QUEEN_object` can be generated from a Benchling shared link with `dbtype="benchling"`.  

**Source code**

```python
from QUEEN.queen import *
plasmid = QUEEN(record="https://benchling.com/s/seq-U4pePb09KHutQzjyOPQV", dbtype="benchling")
```

pX330 plasmid encoding a Cas9 gene and a gRNA expression unit is provided in the above example. The `QUEEN_object` generated here is used in the following example codes in this document.



###  2. Display of parameter values of a QUEEN class object

#### Example code 2.1: Obtaining a parameter values of a QUEEN object.

Print each parameter value of a QUEEN object.

**Source code**

```python
from QUEEN.queen import *
pUC19 = QUEEN(record="50005", dbtype="addgene") #"50005" is Addgene plasmid ID for pUC19 plasmid.
print(pUC19.seq)      #Obtaining the top-strand sequence of a QUEEN object. 
print(len(pUC19.seq)) #Obtaining the length of a top-strand sequence of a QUEEN object 
print(pUC19.rcseq)    #Obtaining the bottom-strand sequence of a QUEEN object.
print(pUC19.topology) #Obtaining the sequence topology of a QUEEN object. 
```



#### Example code 2.2: Print a formatted DNA sequence of a QUEEN class object

**Source code**

```python
from QUEEN.queen import *
fragment = QUEEN(seq="CCGGTATGCG----/----ATACGCAGCT") 
fragment.printsequence(display=True)
```

**Output**

```
5′ CCGGTATGCG---- 3′
3′ ----ATACGCAGCT 5′
```



#### Example code 2.3: Print DNA features of a QUEEN object

Print a tidy data table of annotation features/attributes of `QUEEN_object`.

**Source code**

```python3
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
plasmid.printfeature()
```

**Output**

```
feature_id  feature_type   qualifier:label     start  end   strand  
1           source         source              0      8484  +       
100         primer_bind    hU6-F               0      21    +       
200         promoter       U6 promoter         0      241   +       
300         primer_bind    LKO.1 5'            171    191   +       
400         misc_RNA       gRNA scaffold       267    343   +       
500         enhancer       CMV enhancer        439    725   +       
600         intron         hybrid intron       983    1211  +       
700         regulatory     Kozak sequence      1222   1232  +       
800         CDS            3xFLAG              1231   1297  +       
900         CDS            SV40 NLS            1303   1324  +       
1000        CDS            Cas9                1348   5449  +       
1100        CDS            nucleoplasmin NLS   5449   5497  +       
1200        primer_bind    BGH-rev             5524   5542  -       
1300        polyA_signal   bGH poly(A) signal  5530   5738  +       
1400        repeat_region  AAV2 ITR            5746   5876  +       
1500        repeat_region  AAV2 ITR            5746   5887  +       
1600        rep_origin     f1 ori              5961   6417  +       
1700        primer_bind    F1ori-R             6048   6068  -       
1800        primer_bind    F1ori-F             6258   6280  +       
1900        primer_bind    pRS-marker          6433   6453  -       
2000        primer_bind    pGEX 3'             6552   6575  +       
2100        primer_bind    pBRforEco           6612   6631  -       
2200        promoter       AmpR promoter       6698   6803  +       
2300        CDS            AmpR                6803   7664  +       
2400        primer_bind    Amp-R               7021   7041  -       
2500        rep_origin     ori                 7834   8423  +       
2600        primer_bind    pBR322ori-F         8323   8343  +     
```



### 3. Search for a queried DNA sequence motif in a QUEEN object

`QUEEN_objects` hold `.searchsequene()` function that enables users to search for a queried sequence motif in a QUEEN object's sequence. 

#### Example code 3.1: Search for a DNA sequence motif with regular expression

**Source code **

```Python
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
match_list = plasmid.searchsequence(query="G[ATGC]{19}GGG")
plasmid.printfeature(match_list, seq=True, attribute=["start", "end", "strand"])
```



#### Example code 3.2: Search for a DNA sequence motif with fuzzy matching

**Source code **

```python
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
match_list = plasmid.searchsequence(query="(?:AAAAAAAA){s<=1}")
plasmid.printfeature(match_list, seq=True) 
```



#### Example code 3.3: Search for a DNA sequence with the IUPAC nucleotide code  

```python3
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
match_list = plasmid.searchsequence(query="SWSWSWDSDSBHBRHH")
plasmid.printfeature(match_list, seq=True)
```



### 4. Separation of a QUEEN object to multiple parts

A QUEEN object can be split into multiple parts by using `cutdna` fucntion. For executing `cutdna` operation, you should need to give parameter values specifying cut positions.    

#### Example code 4.1: Cut pX330 plasmid at multiple positions 

Cut a circular plasmid px330 at the three different positions, resulting in the generation of three fragments. Then, cut one of the three fragments again.  

**Source code**

```python
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
fragments = cutdna(plasmid, 1000, 2000, 4000)
fragment3, fragment4 = cutdna(fragments[1], 500)
```



#### Example code 4.2: Digest pX330 plasmid by EcoRI 

QUEEN provides a library of standard restriction enzyme motifs. To simulate a restrictioon enzyme digstion, first, searching for a restriction enzyme motif by `searchsequence`, then, do `cutdna` function by giving the returned value of `searchsequence`    

**Source code**

```python
from QUEEN.queen import *
from QUEEN import cutsite #Import a restriction enzyme library
plasmid = QUEEN(record="input/px330.gb") 
sites = plasmid.searchsequence(cutsite.lib["EcoRI"])
fragments = cutdna(plasmid, *sites)
```



### 5. Extraction of a partial region of a QUEEN object 

A part of QUEEN object can be retrieved by using `cropdna` function. 

#### Example code 5.1: Crop a sequence fragment within a specified region 

To extract the region ranging from the 2,000 bp to 4,000 bp of a QUEEN object, please use `cropdna` function.    

**Source code**

```python
from QUEEN.queen import *
plasmid  = QUEEN(record="input/px330.gb") 
fragment = cropdna(plasmid ,2000, 4000)
```



### 6. Modification of end sequence structures of a QUEEN object 

End sequence structures of a QUEEN-object can be modified by using `modifyends` function.   

#### Example code 6.1: Trim nucleotides from a blunt-ended dsDNA to generate a sticky-ended dsDNA

Sticky ends can be generated by trimming nucleotides where their end structures are given by top and bottom strand strings with `"*"` and `"-"` separated by `"/"`, respectively. The letters `"-"` indicate nucleotide letters to be trimmed, and the letters `"*"` indicate ones to remain. 

**Source code**

```python
from QUEEN.queen import *
plasmid = QUEEN(record="input/px330.gb") 
fragment = cropdna(plasmid, 100, 120)
fragment.printsequence(display=True)
fragment = modifyends(fragment, "-----/*****", "**/--")
fragment.printsequence(display=True)
```

**Output** 

```
5' CTTAACGTTGGCTTGCCACG 3'
3' GAATTGCAACCGAACGGTGC 5'

5' ----ACGTTGGCTTGCCACG 3'
3' GAATTGCAACCGAACGGT-- 5'
```



### 7. Inversion of a QUEEN object

#### Example code 7.1: Invert a QUEEN object

A revese complement of a QUEEN object can be obtained by `flipdna` funciton. You should just do `flipdn(QUEEN_object)` as follow.   

**Source code**

```python
from QUEEN.queen import * 
plasmid   = QUEEN(record="input/px330.gb")
plsmid_rc = flipdna(plasmid) 
```



### 8. Assemble of multiple QUEEN objects

Multiple QUEEN objects wit linear topolovgy can be assemble by using `joindna` function. Therefore, the connecting DNA end structures must include compatible region (i.e., only blunt ends and sequence ends including compatible sticky ends can be assembled). 

#### Example code 8.1: Assemble the EGFP fragment and the backbone of the pX330 plasmid. 

Step1. Generate QUEEN class objecsts for the EGFP fragment and pX330 plasmid.  
Step2. Create EcoRI sites to both ends of the EGFP fragment.  
Step3. Digest the EGFP fragment and pX330 by EcoRI.  
Step4. Assemble the EGFP fragment and linearized pX330.    

**Source code** 　　

```python3
from QUEEN.queen import * 
plasmid  = QUEEN(record="input/px330.gb") #Step1 
EGFP     = QUEEN(record="input/EGFP.fasta") #Step1

sites    = EGFP.searchsequence(cutsite.lib["EcoRI"]) #Step2
insert   = cutdna(EGFP, *sites)[1] #Step2

sites    = plasmid.searchsequence(cutsite.lib["EcoRI"]) #Step3 
backbone = cutdna(plasmid, *sites)[0] #Step3

pEGFP    = joindna(backbone, insert, topology="circular") #Step4 
```



### 9.  Annotating associations of quinalbe functions and  

The methods of QUEEN object `__init__()`, `searchsequence()` and the five functions provided by QUEEN package  `cutdna()`, `cropdna()`, `modifyends()`, `flipdna()`, and `joindna()` can take `process_name`, `prorcess_description`, and `product`. By specifying these parameter values with narrative descriptions representing actual experimental process, you can easily associate Python commands using QUEEN with the corresponding actual experimental processes.


* **process_name (or pn)**:`str` (default: `""`)
  This option enables users to provide label names for process flow groups. An experimental flow composed of sequential operations by quinable functions can be grouped and labeled with a user-defined name by providing the same name to the quinable function operations belonging to the same target group. Such group labels can be, for example, `"PCR 1"`, `"EcoRI digestion"`, `"Gibson Assembly"`, etc. `visualizeflow()` described below takes into account the group information to generate experimental flow maps from `QUEEN_objects`.
* **process_description (or pd)**: `str` (default: `""`)
  Similar to `process_name`, this option enables users to provide narrative descriptions of operations conferred by quinable functions. This enables the generation of the whole "Materials and Methods" description for a DNA construction process along with its DNA construction flow from a `QUEEN_object` (or a QUEEN-generated GenBank file) using the `quine()` function described below. 
* **product**: `str` (default: `""`)
  This option enables users to provide label names for producing `QUEEN_objects`. The provided labels are stored in `QUEEN_objects.project`

Additionally, QUEEN class and the five functions `cutdna()`, `cropdna()`, `modifyends()`, `flipdna()` and `joindna()`  can also take `supfeature` parameter to add supplimental sequence features to the QUEEN object.


* **supfeature**: `dict`, `list` of `dict`, `list` of `list` of `dict`  
  This option can be acceptable by only `QUEEN()` and basic operational fuctions `cutdna()`, `cropdna()`, `modifyends()`, `flipdna()` and `joindna()`. A `dict` object is composed of key-value pairs of the attributes in a DNAfeature object. The DNAfeature object generated based on the dictionary value would be added in the `.dnafeatures` of a newly generated QUEEN object.  
   When adding multiple DNAfeature objects, the value shoud be specified as `list` of `dict`. However, for `cutdna()`, the value should be specified as `list` of `list` of `dict`.  
  The following attributes have default values, so if they are not specified in a `dict` object, the values would be set with the default values.  

  - `feature_id`: `str`, (default: Random unique ID which is not used in `.dnafeatures` of the QUEEN object)  

  - `feature_type`: `str` (default: `"misc_feature"`)  

  - `start`: `int` (default: 0)  

  - `end`: `int` (default: length of the `QUEEN_object` sequence)  

  - `strand`: `int` (-1, 0 or 1, default: 1)  

    

#### Example code 9.1: Create a gRNA expression plasmid

pX330 serves as a standard gRNA expression backbone plasmid. A gRNA spacer can simply be cloned into a BbsI-digested destination site of pX330 as follows:

Step1: Generate a QUEEN object for a sticky-ended gRNA spacer as dsDNA.   
Step2: Digest pX330 by BbsI.   
Step3: Assemble the spacer with BbsI-digested pX330 by ligation reaction.   

**Source code**

```Python
from QUEEN.queen import * 
plasmid  = QUEEN(record="input/px330.gb")

#Step1 
gRNA_top    = QUEEN(seq="CACCGACCATTGTTCAATATCGTCC", ssdna=True, product="gRNA_top")
gRNA_bottom = QUEEN(seq="AAACGGACGATATTGAACAATGGTC", ssdna=True, product="gRNA_bottom")
gRNA       = joindna(gRNA_top, gRNA_bottom, product="aneealed_gRNA", 
                      process_name = "gRNA annealing", 
                      process_description = "Annealing of gRNA oligonucleotides."
                      supfeature={"feature_id":"gRNA-1", "feature_type":"gRNA", "qualifier:label":"gRNA"})

#Step2 
BBsI_sites = plasmid.searchsequence(cutsite.lib["BbsI"], 
                                     process_name="Digestion by BbsI",
																		 process_description="Digest px330 plasmid by BbsI")
fragments  = cutdna(plasmid, *sites, product="digested_fragments", 
                     process_name="Digestion by BbsI", 
                     process_description="Digest px330 plasmid by BbsI")

#Step3
backbone  = fragments[0] if len(fragments[0].seq) > len(fragments[1].seq) else fragment[1] #Select the longer fragment as the backbone.
construct = joindna(gRNA, backbone, topology="circular", product="pX330_gRNA",  
                   process_name="ligation",
                   process_description="Ligation of the digested px330 plaxsmid and the annealed gRNA oligo.")
```